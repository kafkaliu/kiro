# 标准和方法论参考

<!-- 导航元数据 -->
<!-- 资源：标准 | 级别：参考 | 先决条件：无 -->
<!-- 相关：process/requirements-phase.md, templates/requirements-template.md, examples/simple-feature-spec.md -->

**📍 您的位置：** [主指南](../../README.md) → [资源](README.md) → **标准**

## 快速导航
- **📋 应用 EARS：** [需求阶段](../process/requirements-phase.md) - 在实践中使用 EARS 格式
- **📝 使用模板：** [需求模板](../templates/requirements-template.md) - EARS 格式的模板
- **📖 查看示例：** [简单功能规范](../examples/simple-feature-spec.md) - EARS 实际应用
- **🔧 更多工具：** [工具和资源](tools.md) - 其他有用的资源

---

本节提供有关行业标准、方法论和最佳实践的详细信息，这些信息为规范驱动的开发方法提供了依据。

## EARS (简易需求语法方法)

EARS 是一种编写需求的结构化方法，可以使需求清晰、可测试且无歧义。它使用特定的关键字来定义不同类型的需求。

### EARS 关键字和结构

#### WHEN (事件驱动需求)
用于由特定事件或条件触发的需求。

**格式：** `WHEN [事件/触发器] THEN [系统] SHALL [响应]`

**示例：**
- WHEN 用户点击“保存”按钮 THEN 系统 SHALL 验证所有表单字段
- WHEN 文件上传超过 10MB THEN 系统 SHALL 显示错误消息
- WHEN 用户会话过期 THEN 系统 SHALL 重定向到登录页面

#### IF (状态驱动需求)
用于依赖于特定系统状态或条件的需求。

**格式：** `IF [条件] THEN [系统] SHALL [响应]`

**示例：**
- IF 用户未通过身份验证 THEN 系统 SHALL 拒绝访问受保护的资源
- IF 数据库连接失败 THEN 系统 SHALL 显示维护消息
- IF 用户具有管理员权限 THEN 系统 SHALL 显示管理面板

#### WHILE (持续性需求)
用于在持续操作期间必须维持的需求。

**格式：** `WHILE [条件] [系统] SHALL [持续行为]`

**示例：**
- WHILE 文件正在上传 the 系统 SHALL 显示进度指示器
- WHILE 用户正在输入 the 系统 SHALL 提供实时验证反馈
- WHILE 系统正在处理请求 the 系统 SHALL 防止重复提交

#### WHERE (可选需求)
用于仅在特定上下文或位置应用的需求。

**格式：** `WHERE [位置/上下文] [系统] SHALL [行为]`

**示例：**
- WHERE 用户在移动设备上 the 系统 SHALL 使用响应式布局
- WHERE 应用程序在生产模式下运行 the 系统 SHALL 将错误记录到外部服务
- WHERE 多个用户同时编辑 the 系统 SHALL 优雅地处理冲突

### EARS 最佳实践

1.  **使用主动语态**：使用主动语态编写需求以确保清晰
2.  **具体化**：避免使用“用户友好”或“快速”等模糊术语
3.  **每个声明一个需求**：每个 EARS 语句应只包含一个需求
4.  **可测试的结果**：每个需求都应可通过测试进行验证
5.  **术语一致**：在所有需求中始终使用相同的术语

### 需要避免的 EARS 反模式

-   **复合需求**：避免在一个需求中使用多个 SHALL 语句
-   **模糊的条件**：不要使用“在适当时”等不清楚的触发器
-   **实现细节**：关注“什么”，而不是“如何”
-   **不可测试的需求**：避免使用无法衡量的主观术语

## 需求工程的行业标准

### IEEE 830 - 软件需求规范

IEEE 830 为编写软件需求规范 (SRS) 提供了指导方针。关键原则包括：

#### 良好需求的特征
-   **正确**：准确描述预期的功能
-   **无歧义**：只有一种解释
-   **完整**：包含所有必要信息
-   **一致**：与其他需求没有冲突
-   **分级**：按重要性和稳定性进行优先级排序
-   **可验证**：可以进行测试或检查
-   **可修改**：可以在不产生过度影响的情况下进行更改
-   **可追溯**：可以链接到设计和实现

#### SRS 文档结构
1.  引言 (目的、范围、定义)
2.  总体描述 (产品视角、功能、用户特征)
3.  具体需求 (功能性、非功能性、接口)
4.  附录 (支持信息)

### ISO/IEC 25010 - 质量要求

ISO/IEC 25010 定义了系统和软件的质量特征：

#### 功能适用性
-   **功能完整性**：所有指定的功能都存在
-   **功能正确性**：功能提供正确的结果
-   **功能适当性**：功能促进指定的任务

#### 性能效率
-   **时间行为**：响应时间和处理速度
-   **资源利用率**：CPU、内存、存储使用情况
-   **容量**：最大限制和可伸缩性

#### 兼容性
-   **共存性**：可以与其他系统一起运行
-   **互操作性**：可以交换和使用信息

#### 可用性
-   **适当性可识别性**：用户可以识别其适用性
-   **易学性**：易于学习和理解
-   **易操作性**：易于操作和控制
-   **用户错误保护**：防止用户错误
-   **用户界面美学**：令人愉悦的用户界面
-   **可访问性**：可供残障人士使用

#### 可靠性
-   **成熟度**：在正常操作下满足可靠性需求
-   **可用性**：在需要时可操作
-   **容错性**：尽管存在硬件/软件故障仍能运行
-   **可恢复性**：可以从故障中恢复

#### 安全性
-   **机密性**：确保只有授权用户才能访问数据
-   **完整性**：防止未经授权的修改
-   **不可否认性**：证明行为或事件已经发生
-   **问责性**：将行为追溯到实体
-   **真实性**：证明主体或资源的身份

#### 可维护性
-   **模块化**：由离散的组件组成
-   **可重用性**：资产可以在其他系统中使用
-   **可分析性**：易于评估更改的影响
-   **可修改性**：可以在没有缺陷的情况下进行修改
-   **可测试性**：可以建立测试标准

#### 可移植性
-   **适应性**：可以适应不同的环境
-   **可安装性**：可以安装在指定的环境中
-   **可替换性**：可以替换其他软件用于相同目的

## 系统设计和架构最佳实践

### 架构原则

#### SOLID 原则
-   **单一职责**：每个模块只有一个更改的理由
-   **开闭**：对扩展开放，对修改关闭
-   **里氏替换**：子类型必须可以替换其基类型
-   **接口隔离**：客户端不应依赖于未使用的接口
-   **依赖倒置**：依赖于抽象，而不是具体实现

#### 设计模式
-   **创建型**：工厂、生成器、单例
-   **结构型**：适配器、装饰器、外观
-   **行为型**：观察者、策略、命令

#### 架构风格
-   **分层架构**：通过分层实现关注点分离
-   **微服务**：由小型、独立服务组成的分布式系统
-   **事件驱动**：组件通过事件进行通信
-   **六边形**：将核心逻辑与外部关注点隔离

### 系统设计方法论

#### 领域驱动设计 (DDD)
-   **通用语言**：技术和领域专家之间共享的词汇
-   **限界上下文**：围绕领域模型的清晰边界
-   **聚合**：业务规则的一致性边界
-   **领域事件**：捕获重要的业务事件

#### 清洁架构
-   **独立性**：框架、数据库和 UI 相互独立
-   **可测试性**：业务规则可以在没有外部元素的情况下进行测试
-   **UI 独立性**：UI 可以在不更改业务规则的情况下进行更改
-   **数据库独立性**：业务规则不与数据库绑定

#### 十二要素应用
1.  **代码库**：一个在版本控制中跟踪的代码库
2.  **依赖**：明确声明和隔离依赖
3.  **配置**：在环境中存储配置
4.  **后端服务**：将后端服务视为附加资源
5.  **构建、发布、运行**：严格分离构建和运行阶段
6.  **进程**：作为一个或多个无状态进程执行
7.  **端口绑定**：通过端口绑定导出服务
8.  **并发**：通过进程模型进行扩展
9.  **可处置性**：通过快速启动和优雅关闭最大化鲁棒性
10. **开发/生产对等**：保持开发、预演和生产环境尽可能相似
11. **日志**：将日志视为事件流
12. **管理进程**：将管理/维护任务作为一次性进程运行

## 需求工程方法论

### 敏捷需求工程

#### 用户故事
**格式：** `作为一个 [角色]，我想要 [功能]，以便 [好处]`

**特征：**
-   **独立**：可以单独开发
-   **可协商**：可以讨论和完善细节
-   **有价值**：为用户或业务提供价值
-   **可估算**：可以为规划估算大小
-   **小**：可以在一次迭代中完成
-   **可测试**：有明确的验收标准

#### 验收标准
-   定义用户故事何时完成
-   以 Given-When-Then 格式或 EARS 格式编写
-   应具体且可测试
-   由团队和利益相关者共同商定

### 行为驱动开发 (BDD)

#### Gherkin 语法
'''gherkin
功能: 用户认证
  作为一个用户
  我想要登录系统
  以便我可以访问我的个人数据

  场景: 成功登录
    假设 我在登录页面
    当 我输入有效的凭据
    那么 我应该被重定向到仪表板
'''

#### BDD 流程
1.  **发现**：探索和理解需求
2.  **构思**：记录示例和场景
3.  **自动化**：创建可执行的规范

### 基于模型的需求工程

#### 用例建模
-   **参与者**：与系统交互的外部实体
-   **用例**：特定的交互或功能
-   **关系**：包含、扩展和泛化

#### 需求建模技术
-   **实体关系图**：数据关系
-   **状态图**：系统随时间变化的行为
-   **序列图**：组件之间的交互
-   **活动图**：工作流和流程

## 质量保证标准

### 测试标准

#### ISO/IEC/IEEE 29119 - 软件测试
-   **测试计划**：策略和方法
-   **测试设计**：测试用例和规程
-   **测试执行**：运行测试并记录结果
-   **测试监控**：进度跟踪和报告

#### 测试驱动开发 (TDD)
1.  **红色**：编写一个失败的测试
2.  **绿色**：编写最少的代码以通过测试
3.  **重构**：在保持测试绿色的同时改进代码

### 代码质量标准

#### 清洁代码原则
-   **有意义的名称**：使用揭示意图的名称
-   **小函数**：函数应该只做一件事
-   **注释**：代码应该是自文档化的
-   **错误处理**：优雅地处理错误
-   **格式化**：一致的代码格式

#### 代码审查标准
-   **功能性**：代码是否按预期工作？
-   **设计**：代码是否设计良好且适当？
-   **复杂性**：代码是否比必要的更复杂？
-   **测试**：代码是否有正确且设计良好的测试？
-   **命名**：名称是否清晰且适当？
-   **注释**：注释是否清晰且有用？

## 文档标准

### 技术写作最佳实践

#### 结构和组织
-   **逻辑流程**：信息按逻辑顺序呈现
-   **一致的格式**：跨文档的统一结构
-   **清晰的标题**：描述性的章节和子章节标题
-   **交叉引用**：相关信息之间的链接

#### 写作风格
-   **主动语态**：使用主动语态以确保清晰
-   **简洁的语言**：消除不必要的词语
-   **术语一致**：在所有文档中始终使用相同的术语
-   **受众意识**：为您的目标受众写作

### 文档类型

#### API 文档
-   **端点描述**：每个端点的清晰解释
-   **请求/响应示例**：示例输入和输出
-   **错误代码**：全面的错误处理信息
-   **认证**：安全要求和实现

#### 用户文档
-   **入门指南**：快速入门指南和教程
-   **功能指南**：功能的详细解释
-   **故障排除**：常见问题和解决方案
-   **常见问题解答**：常见问题和答案

---

## 参考和延伸阅读

### 标准组织
-   **IEEE** (电气和电子工程师协会): [ieee.org](https://www.ieee.org)
-   **ISO** (国际标准化组织): [iso.org](https://www.iso.org)
-   **W3C** (万维网联盟): [w3.org](https://www.w3.org)

### 需求工程资源
-   "Software Requirements" by Karl Wiegers and Joy Beatty
-   "Writing Effective Use Cases" by Alistair Cockburn
-   "User Stories Applied" by Mike Cohn
-   "Specification by Example" by Gojko Adzic

### 系统设计资源
-   "Clean Architecture" by Robert C. Martin
-   "Domain-Driven Design" by Eric Evans
-   "Building Microservices" by Sam Newman
-   "System Design Interview" by Alex Xu

### 质量保证资源
-   "Clean Code" by Robert C. Martin
-   "The Art of Software Testing" by Glenford Myers
-   "Continuous Delivery" by Jez Humble and David Farley
-   "Release It!" by Michael Nygard

---

[← 返回资源](README.md) | [工具和模板 →](../templates/README.md)
