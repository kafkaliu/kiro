# 任务执行文档

<!-- 导航元数据 -->
<!-- 执行：实施 | 级别：详细指南 | 先决条件：process/tasks-phase.md -->
<!-- 相关：templates/tasks-template.md, examples/simple-feature-spec.md, quality-assurance.md -->

**📍 您的位置：** [主指南](../../README.md) → [执行指南](README.md) → **实施指南**

## 快速导航
- **📋 先决条件：** [任务阶段](../process/tasks-phase.md) - 学习如何创建实施计划
- **📝 任务模板：** [任务模板](../templates/tasks-template.md) - 构建您的实施计划
- **📖 查看示例：** [简单功能任务](../examples/simple-feature-spec.md#tasks-document) - 完整的任务示例
- **✅ 质量控制：** [质量保证](quality-assurance.md) - 维护代码质量

---

## 概述

本指南提供了从已完成的规范中实施功能、在整个开发过程中保持质量以及处理常见实施挑战的分步策略。

## 实施前准备

### 1. 规范验证
在开始实施之前，请确保您的规范是完整的：

- **需求审查**：所有用户故事都有明确的验收标准
- **设计完整性**：架构和组件定义明确
- **任务清晰度**：每个任务都是可操作的，并有明确的可交付成果
- **依赖关系映射**：任务顺序和依赖关系已明确

### 2. 环境准备
设置您的开发环境：

```bash
# 确保已安装开发依赖项
# 设置测试框架
# 配置代码质量工具（linting、格式化）
# 准备版本控制分支策略
```

### 3. 任务优先级排序
审查任务列表并确定：
- **关键路径**：阻塞其他工作的任务
- **快速胜利**：可提供早期验证的简单任务
- **风险区域**：可能需要额外关注的复杂任务
- **集成点**：连接不同组件的任务

## 任务执行策略

### 单一任务专注方法

**规则**：一次只实施一个任务，完全完成后再进行下一个。

#### 步骤1：任务分析
在编码之前，分析当前任务：

1. **阅读任务详情**：了解需要构建什么
2. **审查需求**：检查此任务解决了哪些需求
3. **检查依赖关系**：确保先决条件任务已完成
4. **规划实施**：在编码前概述您的方法

#### 步骤2：实施过程

```markdown
对于每个任务：
1. 将任务状态更新为“进行中”
2. 创建/修改必要的文件
3. 编写测试（如果适用）
4. 实施功能
5. 对照需求进行验证
6. 将任务状态更新为“完成”
7. 使用清晰的消息提交更改
```

#### 步骤3：验证检查点
完成每个任务后：
- **功能测试**：它是否按规定工作？
- **需求检查**：引用的需求是否得到满足？
- **集成测试**：它是否与现有代码一起工作？
- **代码质量**：它是否可维护且文档齐全？

### 实施模式

#### 测试驱动开发集成
当任务涉及可测试的功能时：

1. **先写测试**：基于验收标准
2. **实施以通过测试**：编写最少的代码以满足测试
3. **重构**：在保持测试通过的同时提高代码质量
4. **验证**：确保满足所有需求

#### 增量构建
对于复杂任务：

1. **从简单开始**：首先实施基本功能
2. **增加复杂性**：逐层添加其他功能
3. **频繁验证**：每次增量后进行测试
4. **记录决策**：记录与计划的任何偏差

## 质量维护策略

### 代码质量门禁

#### 开始每个任务之前
- [ ] 完全理解任务需求
- [ ] 有清晰的实施计划
- [ ] 知道如何测试功能
- [ ] 了解它如何与现有代码集成

#### 实施期间
- [ ] 编写干净、可读的代码
- [ ] 添加适当的注释和文档
- [ ] 遵循既定的编码标准
- [ ] 在构建时测试功能

#### 完成每个任务之后
- [ ] 所有测试通过
- [ ] 代码符合质量标准
- [ ] 功能与需求匹配
- [ ] 与现有代码的集成正常工作
- [ ] 文档已更新

### 持续集成实践

#### 版本控制策略
```bash
# 为规范创建功能分支
git checkout -b feature/spec-name

# 每个完成的任务后提交
git add .
git commit -m "完成任务 X.Y：[任务描述]"

# 定期推送以备份工作
git push origin feature/spec-name
```

#### 代码审查检查点
- **自我审查**：在标记任务完成前审查自己的代码
- **同行审查**：获取对复杂或关键任务的反馈
- **架构审查**：验证主要设计决策
- **最终审查**：在合并前完成审查

## 处理实施挑战

### 常见挑战类型

#### 1. 需求模糊
**症状**：不清楚要构建什么，可能存在多种解释
**解决方案**：
- 清楚地记录模糊之处
- 做出合理的假设并记录下来
- 首先实施最简单的解释
- 标记以待与利益相关者澄清

#### 2. 技术复杂性
**症状**：任务似乎比预期的要困难得多
**解决方案**：
- 将任务分解为更小的子任务
- 研究替代方法
- 首先实施简化版本
- 如果需要，考虑更新设计

#### 3. 集成问题
**症状**：新代码与现有系统不能很好地工作
**解决方案**：
- 审查设计的集成点
- 如果需要，创建适配器层
- 更新接口以适应新功能
- 如果有益，考虑重构现有代码

#### 4. 性能问题
**症状**：实施太慢或资源密集
**解决方案**：
- 分析以识别瓶颈
- 首先优化关键路径
- 考虑算法改进
- 记录性能特征

### 阻塞问题解决流程

#### 步骤1：识别阻塞问题
- **技术**：缺少知识，实施复杂
- **需求**：规范不明确，需求冲突
- **依赖关系**：等待其他任务、外部系统
- **资源**：缺少工具、访问权限或信息

#### 步骤2：记录问题
```markdown
## 阻塞问题报告
- **任务**：[任务编号和描述]
- **问题**：[问题的清晰描述]
- **影响**：[这对项目有何影响]
- **尝试的解决方案**：[您尝试了什么]
- **建议的解决方案**：[您建议的方法]
```

#### 步骤3：解决策略
- **研究**：寻找解决方案、最佳实践、示例
- **简化**：临时减少范围或复杂性
- **变通**：实施替代方法
- **升级**：向团队成员或利益相关者寻求帮助

#### 步骤4：更新文档
- 在项目文档中记录解决方案
- 如果解决方案更改了设计，则更新规范
- 与团队分享经验教训

## 进度跟踪和沟通

### 任务状态管理
保持任务状态最新：
- **未开始**：任务尚未开始
- **进行中**：正在积极处理任务
- **已阻塞**：由于外部因素无法继续
- **已完成**：任务已完全实施和验证

### 进度报告
定期更新应包括：
- **已完成的任务**：已完成的工作
- **当前重点**：现在正在做什么
- **即将进行的工作**：队列中的下一个任务
- **阻塞问题**：任何阻碍进展的问题
- **时间表**：预计完成日期

### 文档更新
在您实施时：
- **代码注释**：解释复杂的逻辑和决策
- **README 更新**：保持设置和使用说明最新
- **架构说明**：记录任何设计变更
- **经验教训**：记录见解以备将来项目使用

## 适应和灵活性

### 何时偏离计划

#### 可接受的偏差
- **更好的技术解决方案**：找到了更优越的方法
- **简化的实施**：可以更轻松地实现相同的结果
- **性能优化**：发现了效率改进
- **代码重用**：可以利用现有组件

#### 变更流程
1. **记录建议的变更**：为什么以及将会有什么不同
2. **评估影响**：这对其他任务或需求有何影响
3. **更新文档**：如果需要，修改规范文档
4. **沟通**：将重大变更通知利益相关者
5. **验证**：确保仍满足需求

### 迭代改进
- **回顾**：定期审查哪些有效，哪些无效
- **流程优化**：根据经验调整方法
- **工具评估**：考虑更好的工具或技术
- **知识共享**：记录见解以备将来项目使用

## 成功指标

### 任务级成功
- **功能性**：功能按规定工作
- **质量**：代码符合标准且可维护
- **测试**：适当的测试已到位并通过
- **文档**：实施已正确记录

### 项目级成功
- **需求满意度**：满足所有验收标准
- **时间表遵守**：项目在预期时间内完成
- **质量标准**：满足代码质量指标
- **利益相关者满意度**：交付的功能满足用户需求

---

[← 返回执行指南](README.md) | [质量保证 →](quality-assurance.md)