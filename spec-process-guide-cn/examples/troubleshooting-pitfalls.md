# 故障排除和常见陷阱

<!-- 导航元数据 -->
<!-- 示例：故障排除 | 级别：问题解决 | 先决条件：process/README.md -->
<!-- 相关：prompting/best-practices.md, execution/troubleshooting.md, case-studies.md -->

**📍 您的位置：** [主指南](../../README.md) → [示例](README.md) → **故障排除与陷阱**

## 快速导航
- **📋 学习流程：** [流程指南](../process/README.md) - 采用系统化方法避免陷阱
- **💬 更好的沟通：** [提示最佳实践](../prompting/best-practices.md) - 防止误解
- **⚡ 实施问题：** [执行故障排除](../execution/troubleshooting.md) - 解决编码问题
- **📖 真实示例：** [案例研究](case-studies.md) - 从实际失败中学习

---

一份全面的指南，用于避免规范驱动开发中的常见错误，并在出现问题时进行恢复。

## 按阶段划分的常见陷阱

### 需求阶段的陷阱

#### 1. 模糊或不明确的需求

**问题：**
```markdown
# 糟糕的示例
- 用户应该能够管理他们的数据
- 系统应该快速可靠
- 界面应该用户友好
```

**为什么会失败：**
- 没有可衡量的标准
- 主观术语没有定义
- 缺少具体的用户操作

**解决方案：**
```markdown
# 好的示例
**用户故事：** 作为一个已注册用户，我希望编辑我的个人资料信息，以便我能保持我的账户详情是最新。

#### 验收标准
1. WHEN 用户点击“编辑个人资料” THEN 系统 SHALL 显示一个带有当前个人资料数据的可编辑表单
2. WHEN 用户提交有效的个人资料更改 THEN 系统 SHALL 在2秒内保存更改
3. WHEN 用户输入无效数据 THEN 系统 SHALL 在表单内显示特定的错误消息
```

**恢复策略：**
- 审查每个需求并问“我该如何测试这个？”
- 将主观术语转换为可衡量的标准
- 添加具体的用户操作和系统响应

#### 2. 初始阶段的需求范围蔓延

**问题：**
从“简单的用户登录”开始，最终变成了“具有角色、权限、审计日志和社交认证的完整用户管理系统”。

**为什么会失败：**
- 失去了对核心功能的关注
- 使设计阶段变得难以承受
- 创建了不切实际的实施时间表

**解决方案：**
- 为当前规范定义清晰的边界
- 单独记录“未来的增强功能”
- 使用“可以/应该/必须”优先级框架

**恢复策略：**
```markdown
## 当前规范范围 (必须有)
- 基本的电子邮件/密码认证
- 用户会话管理
- 密码重置功能

## 未来增强功能 (可以有)
- 社交登录集成
- 基于角色的权限
- 审计日志
```

#### 3. 缺少错误和边缘案例

**问题：**
只记录“愉快路径”场景。

**常见的缺失案例：**
- 网络故障
- 无效输入处理
- 并发用户操作
- 系统资源限制

**解决方案：**
对于每个需求，明确考虑：
- 当这个失败时会发生什么？
- 边界条件是什么？
- 系统在压力下应该如何表现？

### 设计阶段的陷阱

#### 1. 从一开始就过度设计

**问题：**
```markdown
# 糟糕的示例 - 对于初始实施过于复杂
## 架构
- 带有事件溯源的微服务
- CQRS 模式实现
- 分布式缓存层
- 消息队列系统
- 带有速率限制的 API 网关
```

**为什么会失败：**
- 增加了不必要的复杂性
- 使实施任务变得难以承受
- 增加了实施失败的可能性

**解决方案：**
```markdown
# 好的示例 - 适合需求
## 架构
- 具有清晰模块分离的单一服务
- 带有连接池的直接数据库访问
- RESTful API 端点
- 简单的认证中间件
```

**恢复策略：**
- 对照实际需求审查每个设计决策
- 问“满足需求的最简单解决方案是什么？”
- 将复杂功能记录为“未来的架构演进”

#### 2. 技术研究不足

**问题：**
在不了解以下情况的情况下做出设计决策：
- 可用的库和框架
- 性能特征
- 集成要求
- 部署约束

**警告信号：**
- 设计假设了不存在的功能
- 没有考虑技术限制
- 缺少集成细节

**解决方案：**
- 在设计阶段研究关键技术决策
- 用概念验证代码验证假设
- 记录技术约束及其影响

#### 3. 设计与实施之间的差距

**问题：**
创建理论上合理但实际上难以实施的设计。

**常见问题：**
- 复杂的数据关系没有清晰的实施路径
- 假设了不存在的库或服务
- 性能要求没有实施策略

**恢复策略：**
- 以实施可行性为重点审查设计
- 将复杂组件分解为更简单、可实施的部分
- 为复杂的设计决策添加实施说明

### 任务阶段的陷阱

#### 1. 任务过大或模糊

**问题：**
```markdown
# 糟糕的示例
- [ ] 实现用户认证系统
- [ ] 创建数据库层
- [ ] 构建 API 端点
```

**为什么会失败：**
- 没有明确的完成标准
- 单个任务工作量太大
- 依赖关系不明确

**解决方案：**
```markdown
# 好的示例
- [ ] 1.1 创建带有验证的用户模型
  - 实现带有电子邮件、密码字段的 User 类
  - 添加电子邮件格式验证
  - 添加密码强度要求
  - 为用户模型验证编写单元测试
  - _需求: 1.2, 2.1_

- [ ] 1.2 实现密码哈希工具
  - 使用 bcrypt 创建密码哈希函数
  - 创建密码验证函数
  - 为密码工具编写单元测试
  - _需求: 1.2, 3.1_
```

**恢复策略：**
- 将大任务分解为 2-4 小时的实施块
- 添加具体的交付成果和测试标准
- 确保每个任务都有明确的完成定义

#### 2. 缺少任务依赖关系

**问题：**
由于先决条件工作未完成而无法实施的任务。

**示例：**
```markdown
- [ ] 2.1 实现用户登录端点
- [ ] 2.2 添加认证中间件
- [ ] 1.1 创建用户模型  # 应该先来！
```

**解决方案：**
- 审查任务顺序以了解逻辑依赖关系
- 确保首先实施基础组件
- 使用反映实施顺序的任务编号

#### 3. 没有集成或端到端任务

**问题：**
所有任务都只关注单个组件，而没有将它们连接在一起。

**缺失的元素：**
- 组件之间的集成
- 端到端工作流测试
- 系统级验证

**解决方案：**
始终包括集成任务：
```markdown
- [ ] 5.1 将认证与 API 端点集成
- [ ] 5.2 创建端到端用户注册流程
- [ ] 5.3 测试完整的登录/登出工作流
```

## 流程级别的陷阱

### 1. 在阶段之间跳过用户批准

**问题：**
在没有在每个步骤进行用户验证的情况下从需求 → 设计 → 任务。

**为什么会失败：**
- 在各个阶段中复合错误
- 用户发现问题时为时已晚，无法有效修复
- 实施与用户期望不符

**恢复策略：**
- 在进入下一阶段之前始终获得明确批准
- 如果稍后发现问题，则返回到适当的阶段
- 不要在实施期间尝试修复基本问题

### 2. 将规范视为不可变的

**问题：**
当实施揭示问题时，拒绝更新需求或设计。

**更好的方法：**
- 规范是可以更新的活文档
- 实施的见解应该为规范的改进提供信息
- 记录更改和理由以供将来参考

### 3. 完美主义瘫痪

**问题：**
花费太多时间完善需求或设计，而不是向前推进。

**警告信号：**
- 多次修订没有显著改进
- 对次要决策的分析瘫痪
- 避免实施阶段

**恢复策略：**
- 为每个阶段设定时间限制
- 追求“足够好”而不是完美
- 记住实施将揭示需要改进的领域

## 恢复策略

### 当需求存在根本性缺陷时

**症状：**
- 设计阶段揭示了重大差距
- 需求相互冲突
- 用户反馈表明存在误解

**恢复步骤：**
1. 停止当前阶段的工作
2. 返回到需求阶段，并明确指出问题
3. 仅关注问题区域的修订
4. 在继续之前获得明确批准

### 当设计不支持需求时

**症状：**
- 任务阶段揭示了实施的不可能性
- 设计复杂性远远超过需求复杂性
- 缺少关键系统组件

**恢复步骤：**
1. 确定具体的设计-需求不匹配之处
2. 修订设计以解决差距
3. 简化过度设计的组件
4. 对照所有需求验证修订后的设计

### 当任务无法实施时

**症状：**
- 任务需要不存在的功能
- 任务依赖关系是循环的或不清楚的
- 单个任务过大或模糊

**恢复步骤：**
1. 对照设计和需求审查任务
2. 将大任务分解为可实施的块
3. 重新排序任务以尊重依赖关系
4. 添加缺失的集成和测试任务

## 预防策略

### 需求阶段预防
- 一致地使用 EARS 格式
- 包括错误案例和边缘条件
- 为每个需求获取具体示例
- 与潜在用户验证需求

### 设计阶段预防
- 在设计期间研究技术决策
- 保持初始设计简单且可扩展
- 记录假设和约束
- 频繁地对照需求验证设计

### 任务阶段预防
- 确保每个任务的工作量为 2-4 小时
- 包括测试和集成任务
- 按依赖顺序排列任务
- 为每个任务引用具体的需求

## 需要注意的警告信号

### 早期警告信号
- 难以向他人解释需求
- 在没有研究的情况下做出设计决策
- 任务看起来难以承受或不清楚
- 抗拒在阶段之间移动

### 关键警告信号
- 在同一阶段多次尝试失败
- 复杂性不断增加而没有增加价值
- 实施持续失败
- 用户对规范内容感到困惑

## 何时重新开始

有时最好的恢复策略是带着经验教训重新开始：

**考虑重新开始的情况：**
- 对用户需求的根本性误解
- 技术方法完全错误
- 规范变得过于复杂难以遵循
- 花在修复上的时间比前进的时间还多

**如何有效地重新开始：**
1. 记录从失败尝试中吸取的教训
2. 确定失败的根本原因
3. 从简化的范围开始
4. 从一开始就应用预防策略

---

[← 返回示例](README.md) | [查看案例研究 →](case-studies.md)