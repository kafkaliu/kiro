# 案例研究：故障排除和陷阱

<!-- 导航元数据 -->
<!-- 示例：案例研究 | 级别：故障排除 | 先决条件：simple-feature-spec.md -->
<!-- 相关：process/README.md, prompting/best-practices.md, execution/troubleshooting.md -->

**📍 您的位置：** [主指南](../../README.md) → [示例](README.md) → **案例研究**

## 快速导航
- **📖 学习基础：** [简单功能规范](simple-feature-spec.md) - 首先查看好的示例
- **📋 流程帮助：** [流程指南](../process/README.md) - 采用系统化方法避免陷阱
- **💬 更好的提示：** [最佳实践](../prompting/best-practices.md) - 更有效地沟通
- **⚡ 执行问题：** [故障排除指南](../execution/troubleshooting.md) - 解决实施问题

---

本节记录了从真实世界的规范驱动开发经验中总结的常见错误、失败方法和经验教训。从这些陷阱中学习可以帮助您避免类似问题，并在问题出现时进行恢复。

## 常见陷阱及如何避免

### 需求阶段的陷阱

#### 陷阱1：模糊或不明确的需求

**问题所在：**
一个团队将需求规定为“系统应该快速且用户友好”。这导致在实施过程中，对于什么构成可接受的性能和可用性产生了分歧。

**不良需求示例：**
```markdown
### 需求 1
**用户故事：** 作为一个用户，我希望应用程序速度快，以便获得良好的体验。

#### 验收标准
1. WHEN 使用应用程序 THEN 它应该很快
2. WHEN 导航 THEN 它应该响应迅速
```

**应该怎么做：**
```markdown
### 需求 1
**用户故事：** 作为一个用户，我希望页面加载能快速完成，以便我能高效地完成任务。

#### 验收标准
1. WHEN 加载主仪表板 THEN 页面 SHALL 在2秒内呈现
2. WHEN 点击导航链接 THEN 新页面 SHALL 在1.5秒内加载
3. WHEN 提交表单 THEN 系统 SHALL 在500毫秒内提供反馈
4. IF 网络条件不佳 THEN 系统 SHALL 在1秒后显示加载指示器
```

**恢复策略：**
- 停止实施，返回需求澄清阶段
- 为所有主观术语定义具体的、可衡量的标准
- 就具体指标获得利益相关者的同意
- 在继续之前更新需求文档

#### 陷阱2：缺少边缘案例和错误场景

**问题所在：**
一个用户认证系统的规范没有考虑密码重置、账户锁定或并发登录场景。这导致了安全漏洞和糟糕的用户体验。

**不完整需求示例：**
```markdown
### 需求 1
**用户故事：** 作为一个用户，我希望用电子邮件和密码登录，以便访问我的账户。

#### 验收标准
1. WHEN 提供正确的凭据 THEN 系统 SHALL 验证用户
2. WHEN 提供不正确的凭据 THEN 系统 SHALL 显示错误
```

**应该怎么做：**
```markdown
### 需求 1
**用户故事：** 作为一个用户，我希望用电子邮件和密码安全登录，以便在维护安全的同时访问我的账户。

#### 验收标准
1. WHEN 提供正确的凭据 THEN 系统 SHALL 验证并创建会话
2. WHEN 提供不正确的凭据 THEN 系统 SHALL 显示通用错误消息
3. WHEN 登录失败5次 THEN 系统 SHALL 临时锁定账户15分钟
4. WHEN 已在别处登录 THEN 系统 SHALL 适当地处理并发会话
5. IF 账户被锁定 THEN 系统 SHALL 提供密码重置选项
6. WHEN 会话过期 THEN 系统 SHALL 要求重新认证
```

**恢复策略：**
- 对所有失败场景进行系统性审查
- 为每个用户故事考虑“不愉快路径”
- 添加安全和边缘案例需求
- 如果处理敏感数据，请与安全专家一起审查

#### 陷阱3：技术特定的需求

**问题所在：**
需求规定“系统必须使用React和Node.js”，而不是关注功能性需求。这限制了设计的灵活性，并使规范的可重用性降低。

**技术耦合需求示例：**
```markdown
### 需求 1
**用户故事：** 作为一名开发者，我希望使用React作为前端，以使UI具有交互性。

#### 验收标准
1. WHEN 构建UI THEN 它 SHALL 使用React组件
2. WHEN 处理状态 THEN 它 SHALL 使用Redux
```

**应该怎么做：**
```markdown
### 需求 1
**用户故事：** 作为一个用户，我想要一个交互式的Web界面，以便我能高效地管理我的数据。

#### 验收标准
1. WHEN 与表单交互 THEN 更改 SHALL 立即反映，无需刷新页面
2. WHEN 数据更新 THEN 界面 SHALL 自动更新
3. WHEN 使用界面 THEN 它 SHALL 在现代Web浏览器上工作
4. IF JavaScript被禁用 THEN 核心功能 SHALL 仍然可以访问
```

**恢复策略：**
- 将功能性需求与实施选择分开
- 将技术决策移至设计阶段
- 关注用户价值和业务成果的需求
- 允许设计阶段评估技术选项

### 设计阶段的陷阱

#### 陷阱4：从一开始就过度设计

**问题所在：**
一个简单的内容管理功能在了解实际使用模式之前，就设计了微服务、事件溯源和复杂的缓存层。

**过度设计示例：**
```markdown
## 架构
内容管理系统将使用：
- 5个具有独立数据库的微服务
- 所有数据变更的事件溯源
- 用于分布式缓存的Redis集群
- 用于所有服务间通信的消息队列
- 用于内容搜索的Elasticsearch
```

**应该怎么做：**
```markdown
## 架构
内容管理系统将从以下开始：
- 具有清晰模块边界的单一服务
- 具有适当索引的传统数据库
- 对频繁访问内容的简单缓存
- 模块间的直接API调用
- 最初使用数据库全文搜索

## 未来扩展考虑
- 模块边界设计支持未来的服务提取
- 数据库模式设计支持未来需要时的事件溯源
- 缓存层抽象以支持分布式缓存
- API设计支持未来的微服务架构
```

**恢复策略：**
- 从满足需求的最简单设计开始
- 为未来的可扩展性进行设计，但不要立即实施
- 在需要复杂性时规划清晰的升级路径
- 专注于解决当前问题，而不是假设的未来问题

#### 陷阱5：错误处理设计不足

**问题所在：**
一个支付处理系统设计侧重于“愉快路径”，但没有充分规划网络故障、超时场景或部分支付状态。

**不完整的错误处理示例：**
```markdown
## 支付处理流程
1. 验证支付信息
2. 收取支付方式
3. 更新订单状态
4. 发送确认邮件
```

**应该怎么做：**
```markdown
## 支付处理流程

### 愉快路径
1. 验证支付信息
2. 收取支付方式
3. 更新订单状态
4. 发送确认邮件

### 错误场景
- **验证失败**：返回特定字段错误，记录尝试
- **支付被拒**：存储尝试，提供替代支付方式
- **网络超时**：实施带指数退避的重试
- **部分收费**：实施幂等性密钥，对账流程
- **数据库失败**：将状态更新排队，实施最终一致性
- **邮件失败**：将邮件排队重试，不使支付失败

### 恢复机制
- 对暂时性故障自动重试
- 用于支付差异的手动对账工具
- 用于支付问题解决的客户服务工具
- 支付系统的健康监控和警报
```

**恢复策略：**
- 绘制出系统中所有可能的故障点
- 为每种类型的故障设计特定的处理方式
- 实施错误条件的监控和警报
- 为复杂故障创建手动恢复程序

#### 陷阱6：忽略非功能性需求

**问题所在：**
一个数据处理系统的设计没有考虑性能、安全或可扩展性需求，导致生产问题。

**缺少非功能性考虑的示例：**
```markdown
## 数据处理设计
系统将：
- 从CSV文件读取数据
- 根据业务规则转换数据
- 将结果存储在数据库中
```

**应该怎么做：**
```markdown
## 数据处理设计

### 功能设计
- 从具有可配置批处理大小的CSV文件读取数据
- 使用可插拔的业务规则引擎转换数据
- 使用事务管理存储结果

### 非功能性设计
- **性能**：每分钟至少处理10,000条记录
- **可扩展性**：支持更大规模数据集的水平扩展
- **安全性**：静态和传输中的数据加密
- **可靠性**：实施检查点以从故障中恢复
- **监控**：跟踪处理指标和错误率
- **可维护性**：支持业务规则的热插拔
```

**恢复策略：**
- 审查需求的隐含非功能性需求
- 添加性能、安全和可扩展性考虑
- 从一开始就设计监控和可观察性
- 规划部署和维护等运营问题

### 任务阶段的陷阱

#### 陷阱7：任务过大或模糊

**问题所在：**
实施任务被定义为“实施用户管理”和“构建API”，导致进度跟踪不清晰，难以估算工作量。

**不良任务定义示例：**
```markdown
- [ ] 1. 实施用户管理
  - 构建所有与用户相关的功能
  - _需求: 1.1, 1.2, 1.3, 2.1, 2.2_

- [ ] 2. 构建API
  - 为所有功能创建REST端点
  - _需求: 3.1, 3.2, 4.1_
```

**应该怎么做：**
```markdown
- [ ] 1. 创建用户数据模型和验证
  - 使用TypeScript类型实现用户界面
  - 使用正则表达式模式创建电子邮件验证
  - 添加密码强度验证（8个以上字符，混合大小写，数字）
  - 为验证函数编写单元测试
  - _需求: 1.1, 1.2_

- [ ] 2. 实施用户注册端点
  - 创建带有请求验证的POST /api/users端点
  - 添加重复电子邮件检查及相应的错误响应
  - 使用bcrypt实现密码哈希
  - 为注册流程编写集成测试
  - _需求: 1.1, 1.3_

- [ ] 3. 构建用户认证端点
  - 创建POST /api/auth/login端点
  - 实现凭据验证和JWT令牌生成
  - 对登录尝试添加速率限制
  - 为认证流程编写集成测试
  - _需求: 2.1, 2.2_
```

**恢复策略：**
- 将大任务分解为具体的、可测试的单元
- 每个任务最多应在1-2天内完成
- 包括具体的交付成果和验收标准
- 为每个任务引用具体的需求

#### 陷阱8：缺少依赖关系和顺序

**问题所在：**
任务定义时没有考虑依赖关系，导致工作受阻和开发流程效率低下。

**不良任务排序示例：**
```markdown
- [ ] 1. 构建用户界面组件
- [ ] 2. 实施API端点
- [ ] 3. 创建数据库模式
- [ ] 4. 设置认证中间件
```

**应该怎么做：**
```markdown
- [ ] 1. 设置项目基础设施
  - 创建数据库模式和迁移
  - 设置开发环境和依赖项
  - 配置测试框架
  - _需求: 所有其他任务的基础_

- [ ] 2. 实施核心数据模型
  - 创建带验证的用户模型
  - 实施数据库存储库层
  - 为数据模型编写单元测试
  - _需求: 1.1, 1.2_

- [ ] 3. 构建认证服务
  - 实施密码哈希和验证
  - 创建JWT令牌生成和验证
  - 为认证逻辑编写单元测试
  - _需求: 2.1, 2.2_

- [ ] 4. 创建API端点
  - 使用认证服务构建用户注册端点
  - 实施带令牌生成的登录端点
  - 为受保护的路由添加认证中间件
  - 为完整的API流程编写集成测试
  - _需求: 1.1, 2.1, 3.1_

- [ ] 5. 构建用户界面组件
  - 创建带验证的注册表单
  - 实施带错误处理的登录表单
  - 添加已认证用户的仪表板
  - 编写组件测试和用户交互测试
  - _需求: 3.2, 3.3_
```

**恢复策略：**
- 绘制出任务间的依赖关系图
- 对任务进行排序，使每个任务都建立在已完成工作的基础上
- 识别阻碍其他工作的关键路径项
- 在可能的情况下考虑并行工作流

#### 陷阱9：测试策略不足

**问题所在：**
任务只关注功能实现，没有充分的测试，导致在开发后期发现错误。

**测试不足的任务示例：**
```markdown
- [ ] 1. 实施用户注册
  - 创建注册表单
  - 添加后端验证
  - 将用户存储在数据库中
  - _需求: 1.1_

- [ ] 2. 添加用户登录
  - 创建登录表单
  - 验证凭据
  - 创建用户会话
  - _需求: 2.1_
```

**应该怎么做：**
```markdown
- [ ] 1. 实施带全面测试的用户注册
  - 创建带验证规则的用户模型
  - 为用户模型验证边缘案例编写单元测试
  - 实施带错误处理的注册API端点
  - 为注册流程（包括错误场景）编写集成测试
  - 创建带客户端验证的注册表单
  - 为完整的注册用户旅程编写端到端测试
  - _需求: 1.1_

- [ ] 2. 添加带安全测试的用户登录
  - 实施带安全密码比较的凭据验证
  - 为认证逻辑（包括时序攻击）编写单元测试
  - 创建带速率限制的登录API端点
  - 为登录流程（包括暴力破解场景）编写集成测试
  - 构建带适当错误处理的登录表单
  - 为登录用户旅程和安全措施编写端到端测试
  - _需求: 2.1_
```

**恢复策略：**
- 为每个实施任务添加测试要求
- 包括单元、集成和端到端测试
- 考虑对敏感功能进行安全测试
- 规划正面和负面测试场景

## 常见问题的恢复策略

### 当需求在实施中期变得不明确时

**症状：**
- 开发人员频繁提出澄清问题
- 在没有利益相关者输入的情况下做出实施决策
- 构建的功能与用户期望不符

**恢复步骤：**
1.  **停止实施**：暂停编码工作，以防构建错误的东西
2.  **记录假设**：列出所有关于不明确需求的假设
3.  **利益相关者审查**：安排与业务利益相关者的即时审查
4.  **澄清和更新**：用具体的、可衡量的标准更新需求文档
5.  **影响评估**：评估需要重做的工作
6.  **明确后继续**：只有在需求明确后才继续实施

### 当设计不支持需求时

**症状：**
- 实施任务似乎不可能或过于复杂
- 当前设计无法满足性能要求
- 实施过程中出现安全或可扩展性问题

**恢复步骤：**
1.  **确定根本原因**：确定设计未能支持哪些需求
2.  **设计审查**：对设计决策进行彻底审查
3.  **替代方案评估**：研究替代的架构方法
4.  **利益相关者沟通**：解释权衡并就优先级获取输入
5.  **设计修订**：用新方法更新设计文档
6.  **任务调整**：修订实施任务以匹配新设计

### 当实施任务受阻时

**症状：**
- 由于缺少依赖项，任务无法开始
- 工作顺序错误
- 团队成员正在等待其他人完成先决条件工作

**恢复步骤：**
1.  **依赖关系映射**：创建所有任务依赖关系的可视化图
2.  **关键路径分析**：识别哪些任务阻碍了最多的其他工作
3.  **并行工作识别**：找到可以同时进行的任务
4.  **任务重新排序**：重新排序任务以优化工作流程
5.  **资源重新分配**：将团队成员分配到未受阻的工作
6.  **定期检查**：实施每日站会以及早发现阻碍问题

### 当质量问题后期出现时

**症状：**
- 集成测试期间发现错误
- 在类似生产的环境中出现性能问题
- 审查期间发现安全漏洞

**恢复步骤：**
1.  **问题分类**：按严重性和影响对问题进行分类
2.  **根本原因分析**：确定问题为何没有更早被发现
3.  **测试差距分析**：识别缺少了哪些测试
4.  **流程改进**：在未来的任务中添加缺少的测试类型
5.  **立即修复**：解决阻碍进度的关键问题
6.  **预防规划**：更新规范流程以防止类似问题

## 从失败方法中吸取的教训

### 案例研究1：过度指定的规范

**背景：**
一个团队创建了一份200页的规范文档，试图在任何实施开始前定义内容管理系统的每一个可能细节。

**问题所在：**
- 规范编写耗时3个月
- 在漫长的规范阶段，需求发生了变化
- 实施揭示了许多规范假设是错误的
- 团队花在更新文档上的时间比构建功能的时间还多

**主要教训：**
- 规范应足够详细以指导实施，而不是取代思考
- 从核心功能开始，然后迭代
- 在全面规范之前用原型验证假设
- 保持规范是随着理解而演变的活文档

### 案例研究2：技术优先的设计

**背景：**
一个团队决定为一个简单的库存管理系统使用微服务、事件溯源和GraphQL，因为这些是“现代”技术。

**问题所在：**
- 由于复杂性，开发时间增加了3倍
- 简单的功能需要跨多个服务进行更改
- 调试变得极其困难
- 团队花在基础设施上的时间比业务逻辑还多

**主要教训：**
- 根据需求选择技术，而不是趋势
- 从简单开始，仅在需要时增加复杂性
- 在做出技术选择时考虑团队的专业知识
- 专注于解决业务问题，而不是展示技术

### 案例研究3：缺失的监控规范

**背景：**
一个数据处理管道的功能被彻底指定，但没有监控、日志记录或可观察性要求。

**问题所在：**
- 生产问题无法调试
- 对系统性能或健康状况没有可见性
- 客户问题无法追溯到根本原因
- 由于缺乏运营洞察力，系统可靠性差

**主要教训：**
- 运营需求与功能需求同等重要
- 监控和可观察性应从一开始就指定
- 考虑系统的整个生命周期，而不仅仅是初始功能
- 包括运营手册和故障排除程序

## 预防策略

### 需求阶段预防

1.  **使用具体示例**：始终包括预期行为的具体示例
2.  **定义验收测试**：为每个需求编写可测试的验收标准
3.  **考虑边缘案例**：系统地思考错误场景和边界条件
4.  **利益相关者审查**：在继续之前获得业务利益相关者的明确批准
5.  **原型验证**：构建小型原型以验证假设

### 设计阶段预防

1.  **从简单开始**：从满足需求的最简单设计开始
2.  **为演进规划**：为未来需求设计，但不要立即实施
3.  **考虑运营**：在设计中包括监控、日志记录和维护
4.  **审查权衡**：明确记录设计决策及其权衡
5.  **通过实施验证**：为复杂的设计决策构建概念验证

### 任务阶段预防

1.  **适当调整任务大小**：每个任务应可在1-2天内完成
2.  **包括测试**：每个实施任务都应包括相应的测试
3.  **映射依赖关系**：理解并记录任务依赖关系
4.  **规划集成**：包括将组件集成在一起的任务
5.  **考虑部署**：包括部署和运营方面的任务

## 快速参考：警告信号

### 需求警告信号
- ❌ 需求使用主观术语而无定义（“快速”、“用户友好”）
- ❌ 未考虑错误场景或边缘案例
- ❌ 技术选择嵌入在需求中
- ❌ 利益相关者未审查或批准需求

### 设计警告信号
- ❌ 设计比需求建议的要复杂得多
- ❌ 未考虑非功能性需求
- ❌ 未规划错误处理或失败场景
- ❌ 设计决策未被证明或记录

### 任务警告信号
- ❌ 任务过大（超过2-3天的工作量）
- ❌ 实施任务中不包括测试
- ❌ 未考虑任务间的依赖关系
- ❌ 未包括集成或部署任务

---

[← 复杂系统示例](complex-system-spec.md) | [返回示例概述](README.md)
