# 简单功能规范示例

<!-- 导航元数据 -->
<!-- 示例：简单功能 | 级别：完整示例 | 先决条件：methodology/README.md -->
<!-- 相关：templates/README.md, process/README.md, complex-system-spec.md -->

**📍 您的位置：** [主指南](../../README.md) → [示例](README.md) → **简单功能规范**

## 快速导航
- **📚 先学基础：** [方法论概述](../methodology/README.md) - 理解基础
- **📝 使用模板：** [模板](../templates/README.md) - 创建您自己的规范
- **📋 遵循流程：** [流程指南](../process/README.md) - 分步说明
- **🏗️ 复杂示例：** [复杂系统规范](complex-system-spec.md) - 更高级的示例

---

本节提供基础功能的完整规范示例，演示了三阶段方法论在实践中的应用。每个示例都包括完整的需求、设计和任务文档，并附有解释关键决策的评注。

## 示例1：用户认证系统

### 概述
一个基本的用户认证系统，允许用户注册、登录和管理他们的会话。此示例演示了如何为一个许多应用程序都需要的基础功能编写规范。

### 完整的规范文档

#### 需求文档

```markdown
# 用户认证系统 - 需求

## 引言
此功能实现了一个安全的用户认证系统，允许用户创建账户、安全登录并维护认证会话。系统将处理用户注册、登录验证、会话管理和基本的安全措施。

## 需求

### 需求 1
**用户故事：** 作为一个新用户，我希望用电子邮件和密码创建一个账户，以便我能访问应用程序的受保护功能。

#### 验收标准
1. WHEN 用户提供有效的电子邮件和密码 THEN 系统 SHALL 创建一个新用户账户
2. WHEN 用户提供一个已存在的电子邮件 THEN 系统 SHALL 返回相应的错误消息
3. WHEN 用户提供无效的电子邮件格式 THEN 系统 SHALL 验证并拒绝输入
4. WHEN 用户提供一个弱密码 THEN 系统 SHALL 强制执行密码强度要求

### 需求 2
**用户故事：** 作为一个已注册用户，我希望用我的凭据登录，以便我能访问我的账户和受保护的功能。

#### 验收标准
1. WHEN 用户提供正确的电子邮件和密码 THEN 系统 SHALL 认证并创建一个会话
2. WHEN 用户提供不正确的凭据 THEN 系统 SHALL 返回一个认证错误
3. WHEN 用户尝试多次失败登录 THEN 系统 SHALL 实施速率限制
4. IF 用户已经登录 THEN 系统 SHALL 适当地处理现有会话

### 需求 3
**用户故事：** 作为一个已登录用户，我希望我的会话能被安全地维护，以便我不需要在保持安全的同时频繁地重新认证。

#### 验收标准
1. WHEN 用户成功登录 THEN 系统 SHALL 创建一个安全的会话令牌
2. WHEN 用户发出认证请求 THEN 系统 SHALL 验证会话令牌
3. WHEN 会话过期 THEN 系统 SHALL 要求重新认证
4. WHEN 用户登出 THEN 系统 SHALL 使会话令牌无效
```

#### 设计文档

```markdown
# 用户认证系统 - 设计

## 概述
认证系统将使用 JWT 令牌进行无状态认证，并使用 bcrypt 进行安全的密码哈希。系统将包括注册、登录、会话验证和带有适当安全措施的登出功能。

## 架构
- **认证服务**：用户管理的核心业务逻辑
- **密码服务**：安全的密码哈希和验证
- **令牌服务**：JWT 令牌生成和验证
- **用户仓库**：用户存储的数据访问层
- **认证中间件**：受保护路由的请求验证

## 组件和接口

### 用户模型
```typescript
interface User {
  id: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  lastLoginAt?: Date;
}
```

### 认证服务
```typescript
interface AuthService {
  register(email: string, password: string): Promise<User>;
  login(email: string, password: string): Promise<{ user: User; token: string }>;
  validateToken(token: string): Promise<User>;
  logout(token: string): Promise<void>;
}
```

## 数据模型
- **用户存储**：带有索引电子邮件字段的数据库表
- **会话管理**：带有过期时间的 JWT 令牌
- **速率限制**：基于内存或 Redis 的尝试跟踪

## 错误处理
- 输入验证错误 (400 Bad Request)
- 认证失败 (401 Unauthorized)
- 速率限制 (429 Too Many Requests)
- 服务器错误 (500 Internal Server Error)

## 测试策略
- 每个服务组件的单元测试
- 完整认证流程的集成测试
- 常见漏洞的安全测试
- 并发认证请求的性能测试
```

#### 任务文档

```markdown
# 用户认证系统 - 实施计划

- [ ] 1. 设置项目结构和依赖项
  - 创建认证模块目录结构
  - 安装所需依赖项 (bcrypt, jsonwebtoken, 验证库)
  - 设置 TypeScript 接口和类型
  - _需求: 1.1, 2.1, 3.1_

- [ ] 2. 实现用户模型和验证
  - 创建用户接口和数据模型
  - 实现电子邮件格式的正则表达式验证
  - 创建密码强度验证 (最小长度，复杂度)
  - 为验证函数编写单元测试
  - _需求: 1.1, 1.3, 1.4_

- [ ] 3. 创建密码安全服务
  - 使用 bcrypt 和适当的 salt 轮数实现密码哈希
  - 创建用于登录验证的密码比较函数
  - 为密码哈希和验证编写单元测试
  - _需求: 1.1, 2.1_

- [ ] 4. 构建 JWT 令牌服务
  - 实现带有用户负载和过期时间的令牌生成
  - 创建令牌验证和解码功能
  - 添加用于登出的令牌黑名单功能
  - 为令牌操作编写单元测试
  - _需求: 2.1, 3.1, 3.2, 3.4_

- [ ] 5. 实现用户仓库层
  - 为用户表创建数据库模式和迁移
  - 实现用户管理的 CRUD 操作
  - 添加电子邮件唯一性约束和索引
  - 为数据库操作编写集成测试
  - _需求: 1.1, 1.2, 2.1_

- [ ] 6. 构建认证服务
  - 实现带有验证和密码哈希的用户注册
  - 创建带有凭据验证的登录功能
  - 为受保护的路由添加会话验证
  - 实现带有令牌失效的登出功能
  - 为所有认证流程编写全面的单元测试
  - _需求: 1.1, 1.2, 2.1, 2.2, 3.1, 3.4_

- [ ] 7. 创建认证中间件
  - 构建用于在受保护路由上验证 JWT 令牌的中间件
  - 实现适当的错误处理和响应格式
  - 添加带有已认证用户信息的请求上下文
  - 为中间件功能编写集成测试
  - _需求: 3.1, 3.2_

- [ ] 8. 实现速率限制和安全措施
  - 为每个 IP/电子邮件的登录尝试添加速率限制
  - 在多次失败尝试后实现账户锁定
  - 创建安全头和 CORS 配置
  - 为安全措施编写测试
  - _需求: 2.3_

- [ ] 9. 创建 API 端点和集成
  - 为注册、登录和登出构建 REST 端点
  - 实现适当的 HTTP 状态码和错误响应
  - 添加请求/响应验证和清理
  - 编写端到端 API 测试
  - _需求: 1.1, 2.1, 3.4_

- [ ] 10. 添加监控和日志记录
  - 为认证事件实现结构化日志记录
  - 添加登录成功/失败率的指标
  - 为可疑认证模式创建警报
  - 为日志记录功能编写测试
  - _需求: 2.3_
```

### 关键决策评注

#### 为什么选择 JWT 令牌？
- **无状态**：无需服务器端会话存储
- **可扩展**：在分布式系统中工作良好
- **标准**：完善的安全实践
- **灵活**：可以包含自定义声明和过期时间

#### 为什么选择 bcrypt 进行密码哈希？
- **自适应**：随着硬件改进可以增加难度
- **内置 Salt**：自动生成 salt 可防止彩虹表攻击
- **久经考验**：广泛使用和审计的安全库
- **可配置**：可调整的工作因子以平衡安全/性能

#### 数据库设计决策
- **电子邮件作为用户名**：对用户更简单，是自然的唯一标识符
- **独立的密码哈希**：绝不存储明文密码
- **时间戳**：跟踪账户创建和上次登录以进行分析
- **索引**：为电子邮件字段建立索引以加快登录时的查找速度

### 实施说明

此规范可转化为大约 8-10 个 TypeScript 文件：
- `models/User.ts` - 数据模型和接口
- `services/AuthService.ts` - 核心认证逻辑
- `services/PasswordService.ts` - 密码哈希工具
- `services/TokenService.ts` - JWT 令牌管理
- `repositories/UserRepository.ts` - 数据库操作
- `middleware/AuthMiddleware.ts` - 请求认证
- `controllers/AuthController.ts` - HTTP 端点处理程序
- `routes/auth.ts` - 路由定义
- `__tests__/` - 全面的测试套件

### 经验教训

**做得好的地方：**
- 将认证分解为离散的服务使测试更容易
- 从清晰的接口开始有助于保持一致性
- 系统地解决了安全问题

**可以改进的地方：**
- 本可以包含更具体的错误消息要求
- 速率限制策略可以在设计阶段更详细
- 未包含密码重置功能，但通常需要

---

## 示例2：数据验证组件

### 概述
一个可重用的数据验证组件，可以使用可自定义的规则验证不同类型的输入数据。此示例展示了如何为一个将在多个功能中使用的实用程序组件编写规范。

### 完整的规范文档

#### 需求文档

```markdown
# 数据验证组件 - 需求

## 引言
此功能实现了一个灵活的数据验证组件，可以使用可配置的规则验证各种类型的输入数据。该组件将支持常见的验证模式、自定义验证函数，并为失败的验证提供清晰的错误消息。

## 需求

### 需求 1
**用户故事：** 作为一个开发者，我想要一个可以验证常见数据类型的验证组件，以便我能确保整个应用程序的数据完整性。

#### 验收标准
1. WHEN 验证字符串数据 THEN 系统 SHALL 支持长度、模式和格式验证
2. WHEN 验证数字数据 THEN 系统 SHALL 支持范围、精度和类型验证
3. WHEN 验证电子邮件地址 THEN 系统 SHALL 使用标准的电子邮件格式验证
4. WHEN 验证日期 THEN 系统 SHALL 支持格式和范围验证

### 需求 2
**用户故事：** 作为一个开发者，我希望定义自定义验证规则，以便我能验证特定领域的数据要求。

#### 验收标准
1. WHEN 定义自定义验证器 THEN 系统 SHALL 接受自定义验证函数
2. WHEN 组合多个验证器 THEN 系统 SHALL 支持验证链
3. WHEN 验证失败 THEN 系统 SHALL 提供特定的错误消息
4. IF 验证通过 THEN 系统 SHALL 返回已验证的数据

### 需求 3
**用户故事：** 作为一个开发者，我希望有清晰的验证错误消息，以便我能向用户提供有意义的反馈。

#### 验收标准
1. WHEN 验证失败 THEN 系统 SHALL 返回描述性的错误消息
2. WHEN 多个验证失败 THEN 系统 SHALL 收集所有错误消息
3. WHEN 显示错误 THEN 系统 SHALL 识别哪个字段验证失败
4. IF 提供了自定义错误消息 THEN 系统 SHALL 使用它们而不是默认消息
```

#### 设计文档

```markdown
# 数据验证组件 - 设计

## 概述
验证组件将实现为一个可组合的验证系统，支持内置验证器和自定义验证函数。它将使用流畅的 API 来链接验证器，并提供详细的错误报告。

## 架构
- **验证器接口**：所有验证函数的通用接口
- **内置验证器**：用于常见用例的预定义验证器
- **验证链**：可组合的验证管道
- **错误收集器**：聚合和格式化验证错误
- **模式验证器**：验证具有多个字段的复杂对象

## 组件和接口

### 核心验证器接口
```typescript
interface Validator<T> {
  validate(value: T): ValidationResult;
  withMessage(message: string): Validator<T>;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  value?: any;
}
```

### 验证链
```typescript
interface ValidationChain<T> {
  required(): ValidationChain<T>;
  string(): ValidationChain<string>;
  number(): ValidationChain<number>;
  email(): ValidationChain<string>;
  minLength(min: number): ValidationChain<string>;
  maxLength(max: number): ValidationChain<string>;
  pattern(regex: RegExp): ValidationChain<string>;
  custom(validator: (value: T) => boolean): ValidationChain<T>;
  validate(value: T): ValidationResult;
}
```

## 数据模型
- **验证规则**：不同验证类型的配置对象
- **错误消息**：本地化的错误消息模板
- **模式定义**：带有字段级规则的对象验证模式

## 错误处理
- 一致地收集和格式化验证错误
- 支持自定义错误消息和国际化
- 用于表单验证的字段级错误映射
- 优雅地处理无效的输入类型

## 测试策略
- 每个内置验证器的单元测试
- 验证链的集成测试
- 边界条件的边缘案例测试
- 大型数据集的性能测试
```

#### 任务文档

```markdown
# 数据验证组件 - 实施计划

- [ ] 1. 设置验证组件结构
  - 创建验证模块目录和核心接口
  - 为验证器和结果定义 TypeScript 类型
  - 设置测试框架和初始测试结构
  - _需求: 1.1, 2.1, 3.1_

- [ ] 2. 实现核心验证接口
  - 创建基础验证器接口和 ValidationResult 类型
  - 使用流畅的 API 实现 ValidationChain 类
  - 创建错误收集和格式化工具
  - 为核心接口编写单元测试
  - _需求: 2.1, 2.2, 3.1, 3.2_

- [ ] 3. 构建内置字符串验证器
  - 实现 required, minLength, maxLength 验证器
  - 创建支持正则表达式的模式匹配验证器
  - 添加带有全面正则表达式的电子邮件格式验证
  - 为所有字符串验证器编写单元测试
  - _需求: 1.1, 1.3_

- [ ] 4. 创建数字验证器
  - 实现数字类型验证和转换
  - 添加 min, max 和范围验证函数
  - 创建精度和小数位验证器
  - 为数字验证边缘案例编写单元测试
  - _需求: 1.2_

- [ ] 5. 实现日期和时间验证器
  - 创建日期格式验证和解析
  - 添加日期范围验证器 (before, after, between)
  - 实现时间格式验证
  - 为各种日期格式和边缘案例编写单元测试
  - _需求: 1.4_

- [ ] 6. 构建自定义验证支持
  - 实现自定义验证器函数接口
  - 为多个验证器创建验证链组合
  - 添加条件验证支持
  - 为自定义验证器集成编写单元测试
  - _需求: 2.1, 2.2_

- [ ] 7. 创建错误消息系统
  - 实现默认错误消息模板
  - 添加对每个验证器的自定义错误消息的支持
  - 为动态值创建错误消息插值
  - 为错误消息生成和格式化编写测试
  - _需求: 3.1, 3.2, 3.4_

- [ ] 8. 构建对象模式验证
  - 为复杂对象创建模式定义接口
  - 实现带有错误映射的字段级验证
  - 添加嵌套对象验证支持
  - 为完整的对象验证编写集成测试
  - _需求: 2.2, 3.3_

- [ ] 9. 添加验证工具和帮助程序
  - 创建验证结果聚合工具
  - 为常见框架实现验证中间件
  - 添加表单验证帮助程序和集成示例
  - 编写全面的集成测试
  - _需求: 2.2, 3.3_

- [ ] 10. 性能优化和最终确定
  - 优化验证链的性能
  - 为已编译的正则表达式模式添加缓存
  - 创建全面的文档和用法示例
  - 编写性能测试和基准测试
  - _需求: 1.1, 2.1, 3.1_
```

### 关键决策评注

#### 为什么选择流畅的 API 设计？
- **开发者体验**：直观的链式语法
- **可组合性**：易于组合多个验证器
- **可读性**：验证规则读起来像自然语言
- **灵活性**：可以在不破坏现有代码的情况下添加新的验证器

#### 错误收集策略
- **全面**：收集所有验证错误，而不仅仅是第一个
- **结构化**：所有验证器都有一致的错误格式
- **可定制**：允许自定义错误消息以获得更好的用户体验
- **可本地化**：支持国际化

### 实施说明

此规范可转化为一个模块化的验证库：
- `core/Validator.ts` - 基础接口和类型
- `core/ValidationChain.ts` - 流畅的 API 实现
- `validators/StringValidators.ts` - 字符串验证函数
- `validators/NumberValidators.ts` - 数字验证函数
- `validators/DateValidators.ts` - 日期/时间验证函数
- `utils/ErrorCollector.ts` - 错误聚合工具
- `schema/ObjectValidator.ts` - 复杂对象验证
- `__tests__/` - 全面的测试覆盖

### 经验教训

**做得好的地方：**
- 流畅的 API 使组件对开发者非常友好
- 分离内置和自定义验证器提供了良好的灵活性
- 全面的错误收集改善了调试体验

**可以改进的地方：**
- 本可以更清楚地指定性能要求
- 未考虑异步验证支持，但可能需要
- 与流行的表单库的集成可以更详细

---

## 使用指南

### 何时使用这些示例

**用户认证示例** 适用于：
- 学习如何为安全关键功能编写规范
- 理解如何分解复杂的业务逻辑
- 查看安全要求如何转化为实施任务

**数据验证示例** 适用于：
- 理解实用程序组件规范
- 学习如何设计可重用、可组合的系统
- 查看开发者体验要求如何驱动设计决策

### 调整这些示例

两个示例都可以根据不同的上下文进行调整：
- **技术栈**：在保持结构的同时替换特定技术
- **复杂性级别**：根据项目需求添加或删除功能
- **领域要求**：在维护流程的同时修改业务规则
- **集成需求**：根据现有系统架构调整接口

---

[← 返回示例概述](README.md) | [复杂系统示例 →](complex-system-spec.md)