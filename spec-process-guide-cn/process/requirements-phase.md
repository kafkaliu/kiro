# 需求阶段文档

<!-- 导航元数据 -->
<!-- 阶段：需求 | 级别：详细指南 | 先决条件：methodology/README.md -->
<!-- 相关：templates/requirements-template.md, resources/standards.md, examples/simple-feature-spec.md -->

**📍 您的位置：** [主指南](../../README.md) → [流程指南](README.md) → **需求阶段**

## 快速导航
- **🎯 开始使用：** [需求模板](../templates/requirements-template.md) - 即用型模板
- **📖 查看示例：** [简单功能规范](../examples/simple-feature-spec.md) - 完整的需求示例
- **📚 学习 EARS：** [标准参考](../resources/standards.md) - EARS 格式详情
- **➡️ 下一阶段：** [设计阶段](design-phase.md) - 需求批准后

## 阶段导航
- **上一步：** [流程概述](README.md) - 三阶段工作流
- **当前：** **需求阶段** - 将想法转化为结构化需求
- **下一步：** [设计阶段](design-phase.md) - 创建技术架构
- **最终：** [任务阶段](tasks-phase.md) - 分解为实施步骤

---

## 概述

需求阶段是规范驱动开发的基础，在此阶段，使用 EARS（简易需求语法方法）格式将粗略的功能构想转化为清晰、可测试的需求。此阶段确保所有利益相关者在进入设计和实施之前对需要构建的内容有共同的理解。

## 目的和目标

需求阶段旨在：
- 将模糊的功能构想转化为具体、可衡量的需求
- 为功能成功建立明确的验收标准
- 在利益相关者之间建立共同的理解
- 为设计和实施决策提供基础
- 实现有效的测试和验证策略

## 分步流程

### 步骤1：初始需求生成

**目标**：根据功能构想创建需求初稿

**流程**：
1. **分析功能构想**：将核心概念分解为面向用户的功能
2. **确定用户角色**：确定谁将与该功能交互
3. **定义用户故事**：以“作为 [角色]，我希望 [功能]，以便 [好处]”的格式创建用户故事
4. **生成验收标准**：为每个用户故事编写 EARS 格式的需求

**关键原则**：
- 从用户体验开始，而不是技术实施
- 关注可观察、可测试的行为
- 考虑边缘案例和错误场景
- 思考完整的用户旅程

### 步骤2：需求结构和格式

**文档结构**：
```markdown
# 需求文档

## 引言
[功能及其目的的简要概述]

## 需求

### 需求 1
**用户故事：** 作为 [角色]，我希望 [功能]，以便 [好处]

#### 验收标准
1. WHEN [事件] THEN [系统] SHALL [响应]
2. IF [前提条件] THEN [系统] SHALL [响应]
3. WHEN [事件] AND [条件] THEN [系统] SHALL [响应]

### 需求 2
[继续其他需求...]
```

**EARS 格式指南**：
- **WHEN**：描述触发事件或条件
- **IF**：描述必须满足的前提条件
- **THEN**：描述系统所需的响应
- **SHALL**：表示强制性行为（一致使用）
- **AND/OR**：在必要时组合条件

### 步骤3：需求验证

**验证标准**：
- [ ] 每个需求都是可测试和可衡量的
- [ ] 需求涵盖正常、边缘和错误案例
- [ ] 用户故事提供清晰的业务价值
- [ ] 验收标准具体且无歧义
- [ ] 需求是独立的，不相互冲突
- [ ] 涵盖了所有用户角色和交互

**常见验证问题**：
- 此需求可以自动测试吗？
- 预期行为是否已明确定义？
- 是否有任何需要明确说明的假设？
- 出现问题时会发生什么？
- 是否有任何缺失的用户场景？

### 步骤4：迭代求精

**求精流程**：
1. **与利益相关者审查**：获取关于完整性和准确性的反馈
2. **识别差距**：寻找缺失的场景或不明确的需求
3. **澄清歧义**：解决任何模糊或冲突的需求
4. **添加缺失的细节**：包括边缘案例和错误处理
5. **验证业务价值**：确保每个需求都有明确的目的

**迭代指南**：
- 一次只进行一个集中的更改
- 更改后始终要求明确批准
- 记录需求决策背后的理由
- 将需求保持在适当的详细程度（不要太高，也不要太低）

## EARS 格式深入探讨

### 基本 EARS 模式

**简单事件-响应**：
```
WHEN [用户点击提交按钮] THEN [系统] SHALL [验证表单数据]
```

**条件行为**：
```
IF [用户已认证] THEN [系统] SHALL [显示用户仪表板]
```

**复杂条件**：
```
WHEN [用户提交表单] AND [所有必填字段均已完成] THEN [系统] SHALL [处理提交]
```

**错误处理**：
```
WHEN [用户提交无效数据] THEN [系统] SHALL [显示特定的错误消息]
```

### 高级 EARS 模式

**基于状态的需求**：
```
WHEN [系统处于维护模式] THEN [系统] SHALL [向所有用户显示维护消息]
```

**性能要求**：
```
WHEN [用户请求数据] THEN [系统] SHALL [在2秒内响应]
```

**安全要求**：
```
IF [用户会话过期] THEN [系统] SHALL [重定向到登录页面]
```

## 格式良好的需求示例

### 示例1：用户认证功能

**用户故事**：作为一个新用户，我希望创建一个账户，以便我能访问个性化功能。

**验收标准**：
1. WHEN 用户提供有效的电子邮件和密码 THEN 系统 SHALL 创建新账户
2. WHEN 用户提供已存在的电子邮件 THEN 系统 SHALL 显示“电子邮件已注册”错误
3. WHEN 用户提供无效的电子邮件格式 THEN 系统 SHALL 显示“无效的电子邮件格式”错误
4. WHEN 用户提供短于8个字符的密码 THEN 系统 SHALL 显示“密码太短”错误
5. WHEN 账户创建成功 THEN 系统 SHALL 发送确认电子邮件
6. WHEN 账户创建成功 THEN 系统 SHALL 重定向到欢迎页面

### 示例2：数据验证功能

**用户故事**：作为一个用户，我希望我的输入得到验证，以便我不会提交不正确的信息。

**验收标准**：
1. WHEN 用户在必填字段中输入数据 THEN 系统 SHALL 移除任何错误高亮
2. WHEN 用户提交带有空必填字段的表单 THEN 系统 SHALL 用红色高亮缺失的字段
3. WHEN 用户输入无效的数据格式 THEN 系统 SHALL 在字段下方显示格式要求
4. WHEN 所有验证通过 THEN 系统 SHALL 启用提交按钮
5. IF 验证失败 THEN 系统 SHALL 保持提交按钮禁用

### 示例3：文件上传功能

**用户故事**：作为一个用户，我希望上传文件，以便我能与我的团队共享文档。

**验收标准**：
1. WHEN 用户选择小于 10MB 的文件 THEN 系统 SHALL 接受文件上传
2. WHEN 用户选择大于 10MB 的文件 THEN 系统 SHALL 显示“文件太大”错误
3. WHEN 用户选择不支持的文件类型 THEN 系统 SHALL 显示“不支持的格式”错误
4. WHEN 上传正在进行 THEN 系统 SHALL 显示进度指示器
5. WHEN 上传成功完成 THEN 系统 SHALL 显示成功消息
6. WHEN 上传失败 THEN 系统 SHALL 显示重试选项
7. IF 用户未认证 THEN 系统 SHALL 在上传前重定向到登录

## 常见陷阱及如何避免

### 陷阱1：模糊的需求
**问题**：“系统应该很快”
**解决方案**：“WHEN 用户请求数据 THEN 系统 SHALL 在2秒内响应”

### 陷阱2：需求中包含实施细节
**问题**：“系统应使用 Redis 进行缓存”
**解决方案**：“WHEN 用户请求频繁访问的数据 THEN 系统 SHALL 返回缓存结果”

### 陷阱3：缺少错误案例
**问题**：只定义愉快路径场景
**解决方案**：始终为错误条件包括 WHEN/IF 语句

### 陷阱4：需求冲突
**问题**：相互矛盾的需求
**解决方案**：一起审查所有需求并明确解决冲突

### 陷阱5：无法测试的需求
**问题**：“系统应该用户友好”
**解决方案**：“WHEN 新用户完成入门引导 THEN 系统 SHALL 要求不超过3次点击即可到达主要功能”

## 质量清单

在进入设计阶段之前，请验证：

**完整性**：
- [ ] 已识别并解决了所有用户角色
- [ ] 涵盖了正常、边缘和错误案例
- [ ] 所有用户交互都有定义的系统响应
- [ ] 已捕获业务规则和约束

**清晰性**：
- [ ] 每个需求都使用精确、无歧义的语言
- [ ] 技术术语已避免或在词汇表中明确定义
- [ ] 需求是从用户角度编写的
- [ ] 预期行为是具体和可衡量的

**一致性**：
- [ ] EARS 格式在整个文档中一致使用
- [ ] 术语在所有需求中保持一致
- [ ] 需求不相互矛盾
- [ ] 类似场景的处理方式类似

**可测试性**：
- [ ] 每个需求都可以通过测试进行验证
- [ ] 成功标准是可观察和可衡量的
- [ ] 需求指定了输入和预期输出
- [ ] 验收标准足够具体以指导测试创建

## 常见问题故障排除

### 问题：需求不断增长
**症状**：在审查期间不断添加新需求
**解决方案**：尽早设定范围边界，并将范围外的项目记录下来以备将来迭代

### 问题：利益相关者意见不一
**症状**：不同利益相关者希望有冲突的功能
**解决方案**：促进讨论以了解潜在需求并找到折衷方案

### 问题：需求过于技术化
**症状**：需求关注实施而非用户需求
**解决方案**：从用户角度重构需求，并将技术细节移至设计阶段

### 问题：需求过于模糊
**症状**：无法测试或衡量的验收标准
**解决方案**：问“我们如何知道此需求已满足？”并使标准更具体

## 下一步

一旦需求完成并获得批准：
1. **过渡到设计阶段**：使用需求作为系统设计的基础
2. **保持可追溯性**：确保设计决策可以追溯到具体需求
3. **保持需求更新**：如果设计揭示了差距或冲突，则更新需求
4. **准备实施**：需求将指导任务分解和测试策略

需求阶段为之后的一切奠定了基础。花时间把需求做好，可以在设计和实施阶段节省大量精力。